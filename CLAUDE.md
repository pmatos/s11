# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

s11 is an AArch64 superoptimizer written in Rust. It finds shorter or faster equivalent instruction sequences using multiple search strategies and SMT-based equivalence checking.

**Key Features:**
- ELF binary reading and disassembly using Capstone engine
- 20 AArch64 instructions: MOV, ADD, SUB, AND, ORR, EOR, LSL, LSR, ASR, MUL, SDIV, UDIV, CMP, CMN, TST, CSEL, CSINC, CSINV, CSNEG
- Four search algorithms: enumerative, stochastic (MCMC), symbolic (SMT synthesis), and hybrid
- SMT-based equivalence checking using Z3
- Multi-threaded parallel search with worker coordination
- ISA abstraction supporting AArch64 (primary) and RISC-V (secondary)
- Binary patching for applying optimizations

## Development Commands

This project uses `just` as the task runner. Common commands:

- `just build` - Build in debug mode
- `just release` - Build in release mode (optimized)
- `just run` - Build and run in debug mode
- `just run-release` - Build and run in release mode
- `just test` - Run tests
- `just check` - Check code without building
- `just fmt` - Format code
- `just clean` - Clean build artifacts

Standard Cargo commands also work:
- `cargo build`
- `cargo run`
- `cargo test`
- `cargo fmt`

### CI Checks

**IMPORTANT**: Before committing and pushing, always run `./ci_check.sh` to ensure your code will pass CI. This script runs:
1. Code formatting check (`cargo fmt -- --check`)
2. Project build
3. Unit tests
4. Test binary builds
5. Full test suite

This prevents pushing code that will fail CI checks.

Note: Clippy linting is run separately in the `rust-clippy.yml` workflow which performs security analysis and uploads results to GitHub's security tab.

## Dependencies

The project requires:
- Rust toolchain with 2021 edition support
- External crates: `elf`, `capstone`, `clap`, `z3`, `rayon`, `crossbeam-channel`
- Capstone engine (usually installed via system package manager)
- Z3 SMT solver and development libraries (for semantic equivalence checking)
- `just` command runner for running build tasks (required by test_all.sh)

## Architecture

### Module Structure

```
src/
├── main.rs              # CLI and ELF binary analysis
├── ir/                  # Intermediate Representation
│   ├── types.rs         # Register, Operand, Condition enums
│   └── instructions.rs  # Instruction enum (20 opcodes)
├── isa/                 # ISA Abstraction Layer
│   ├── traits.rs        # ISA trait definitions
│   ├── aarch64.rs       # AArch64 backend
│   └── riscv.rs         # RISC-V backend
├── semantics/           # Execution semantics
│   ├── concrete.rs      # Concrete interpreter
│   ├── smt.rs           # Symbolic interpreter (Z3)
│   ├── equivalence.rs   # SMT equivalence checking
│   ├── cost.rs          # Instruction cost model
│   └── state.rs         # Machine state (registers, flags)
├── search/              # Search algorithms
│   ├── enumerative/     # Exhaustive search
│   ├── stochastic/      # MCMC with Metropolis-Hastings
│   ├── symbolic/        # SMT-based synthesis
│   └── parallel/        # Multi-threaded coordination
├── validation/          # Input validation
│   ├── live_out.rs      # Live-out register tracking
│   └── random.rs        # Random input generation
└── assembler/           # Machine code generation (dynasm)
```

### Search Algorithms

1. **Enumerative**: Exhaustively enumerate candidate sequences
2. **Stochastic**: MCMC with mutation operators (opcode, operand, swap, instruction)
3. **Symbolic**: SMT-based synthesis with cost bounding
4. **Hybrid**: Parallel combination of symbolic + stochastic workers

### Key CLI Options

```bash
# Disassemble a binary
s11 disasm --binary <file>

# Optimize a code region
s11 opt --binary <file> --start-addr <hex> --end-addr <hex>

# Algorithm selection
s11 opt ... --algorithm [enumerative|stochastic|symbolic|hybrid]

# Parallel execution
s11 opt ... --cores <n> --timeout <seconds>

# Stochastic parameters
s11 opt ... --beta <inverse-temp> --iterations <n>
```

### Equivalence Checking

The optimizer verifies semantic equivalence using:
1. **Fast validation**: Random input testing (16 test cases)
2. **SMT verification**: Z3 bitvector constraints for formal proof

Example equivalences the optimizer can prove:
- `MOV X0, X1; ADD X0, X0, #1` ≡ `ADD X0, X1, #1`
- `MOV X0, #0` ≡ `EOR X0, X0, X0`
- `ADD X0, X1, X2` ≡ `ADD X0, X2, X1` (commutativity)

## Commit Guidelines

- Do not mention code being co-authored or generated by Claude in commits.
